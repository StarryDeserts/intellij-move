{
    parserClass="org.sui.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"

    implements="org.sui.lang.core.psi.MvElement"
    extends="org.sui.lang.core.psi.MvElementImpl"

    psiPackage="org.sui.lang.core.psi"
    psiImplPackage="org.sui.lang.core.psi.impl"
    parserUtilClass="org.sui.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.sui.lang.MvElementTypes"

    elementTypeClass="org.sui.lang.core.MvElementType"
    tokenTypeClass="org.sui.lang.core.MvTokenType"

    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    extends("(Lambda|Ref|Path|Tuple|Unit|Parens)Type")=Type

    elementType(".+BinExpr")=BinaryExpr
    elementType(".+BinOp")=BinaryOp

    name(".+BinOp")="operator"
    name(".*Expr")="expression"
    name(".*Pat")="pattern"

    extraRoot(".*CodeFragmentElement")=true

    extends(".*Stmt")=Stmt

    consumeTokenMethod("((?!.*_with_recover).*_recover)|(.*_first)|(.*Expr)") = "consumeTokenFast"

    generateTokenAccessors=true

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'
//        EOL_COMMENT='regexp:(//.*\n)|(//.*\R)'
//        BLOCK_COMMENT='regexp:/\*(.|\s)*\*/'

        PLACEHOLDER_ADDRESS='regexp:\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'
        DIEM_ADDRESS='regexp:0x[0-9a-fA-F]{1,40}'
        BECH32_ADDRESS='regexp:wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'
        POLKADOT_ADDRESS='regexp:[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'

        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u16)|(u32)|(u64)|(u128)|(u256))?'
        HEX_INTEGER_LITERAL='regexp:0x[0-9a-fA-F]+((u8)|(u16)|(u32)|(u64)|(u128)|(u256))?'

        HEX_STRING_LITERAL='regexp:x\"([A-F0-9a-f]*)\"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_IDENT='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
//        PLUSEQ      =  '+='
        PLUS        =  '+'
//        MINUSEQ     =  '-='
        MINUS       =  '-'
//        OREQ        =  '|='
//        ANDAND      =  '&&'
//        ANDEQ       =  '&='
//        AND         =  '&'
//        OR          =  '|'
//        LT          =  '<'
//        XOREQ       =  '^='
        XOR         =  '^'
//        MULEQ       =  '*='
        MUL         =  '*'
//        DIVEQ       =  '/='
        DIV         =  '/'
//        REMEQ       =  '%='
        MODULO         =  '%'

        AT         =  '@'
        HASH         =  '#'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'
        DOT_DOT     = '..'

        ADDRESS     = 'address_kw'
        HAS     = 'has_kw'
        ENTRY     = 'entry_kw'
        INLINE     = 'inline_kw'
        FRIEND     = 'friend_kw'

        SCRIPT_KW     = 'script_kw'
        MODULE_KW     = 'module'
        STRUCT_KW     = 'struct_kw'
        CONST_KW     = 'const_kw'
        SCHEMA_KW     = 'schema_kw'

        LOCAL     = 'local_kw'
        GLOBAL     = 'global_kw'
        PRAGMA     = 'pragma_kw'
        POST     = 'post_kw'
        EMITS     = 'emits_kw'
        TO     = 'to_kw'
        APPLY     = 'apply_kw'
        INTERNAL     = 'internal_kw'
        EXCEPT     = 'except_kw'
        WITH     = 'with_kw'
        INCLUDE     = 'include_kw'
        INVARIANT     = 'invariant_kw'
        AXIOM     = 'axiom_kw'

        PACK     = 'pack_kw'
        UNPACK     = 'unpack_kw'
        UPDATE     = 'update_kw'

        ASSERT     = 'assert_kw'
        ASSUME     = 'assume_kw'
        MODIFIES     = 'modifies_kw'
        ENSURES     = 'ensures_kw'
        REQUIRES     = 'requires_kw'
        DECREASES     = 'decreases_kw'
        ABORTS_IF     = 'aborts_if_kw'
        ABORTS_WITH     = 'aborts_with_kw'

        CHOOSE     = 'choose_kw'
        MIN     = 'min_kw'

        FORALL     = 'forall_kw'
        EXISTS     = 'exists_kw'
        WHERE     = 'where_kw'
        IN     = 'in_kw'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (NamedAddressDef | Script | AddressDef | Module | ModuleSpec)*

QualPathCodeFragmentElement ::= FQModulePathIdent? TypeArgumentList?

Attr ::= '#' '[' <<non_empty_comma_sep_items AttrItem>> ']' { pin = 1 }
AttrItem ::= IDENTIFIER AttrItemArguments?
{
    implements = [ "org.sui.lang.core.psi.MvNamedElement" ]
    mixin = "org.sui.lang.core.psi.ext.MvAttrItemMixin"
}
AttrItemArguments ::= '(' <<non_empty_comma_sep_items AttrItemArgument>> ')'
AttrItemArgument ::= IDENTIFIER ('=' Expr)?
{
    implements = [
        "org.sui.lang.core.resolve.ref.MvReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvAttrItemArgumentMixin"
}

NamedAddressDef ::= address IDENTIFIER '=' AddressRef ';' { pin = 3 }

Script ::= SCRIPT_KW ScriptBlock {
    pin = 1
//    mixin = "org.sui.lang.core.psi.ext.MvScriptMixin"
}
ScriptBlock ::= '{' ScriptBlockItems '}' {
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvImportsOwner"
    ]
}
private ScriptBlockItems ::= ScriptItem*

private ScriptItem ::= !('}' | <<eof>>) ScriptItem_item
{
    pin = 1
    recoverWhile = ScriptItem_recover
}
// top-level recovery
private ScriptItemFirst ::= use | CONST_KW | fun
private ScriptItem_recover ::= !('}' | <<eof>> | ScriptItemFirst)

private ScriptItem_item ::= UseStmt | Const | FunctionInner

private address ::= <<addressKeyword>>
private has ::= <<hasKeyword>>
private entry ::= <<entryKeyword>>
private inline ::= <<inlineKeyword>>
private schema ::= <<schemaKeyword>>
//private vector ::= <<vectorKeyword>>

AddressDef ::= address AddressRef AddressBlock {
    pin = 1
    mixin = "org.sui.lang.core.psi.ext.MvAddressDefMixin"
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= Module*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

Module ::= Attr* MODULE_KW (AddressRef '::')? IDENTIFIER ModuleBlock
{
    pin = "MODULE_KW"
    name = "module declaration"
    implements = [
        "org.sui.lang.core.psi.MvQualNamedElement"
        "org.sui.lang.core.psi.MvNameIdentifierOwner"
        "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvModuleMixin"
    stubClass = "org.sui.lang.core.stubs.MvModuleStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvImportsOwner"
    ]
}
private ModuleBlockItems ::= ModuleItem*
private ModuleItem ::= !('}' | <<eof>>) ModuleItem_item
{
    pin = 1
    recoverWhile = Item_recover
}
// top-level recovery
private Item_first ::= use | public | native | fun | CONST_KW | STRUCT_KW | spec | friend | Attr | entry | inline
private Item_recover ::= !('}' | <<eof>> | Item_first)

private ModuleItem_item ::= UseStmt
                            | FriendDecl
                            | StructItem
                            | FunctionItem
                            | SpecFunctionItem
                            | Const
                            | Schema
                            | ModuleItemSpec
                            | ItemSpec

Const ::= Attr* CONST_KW IDENTIFIER TypeAnnotation Initializer ';'
{
    pin = "CONST_KW"
    implements = [
        "org.sui.lang.core.psi.MvQualNamedElement"
        "org.sui.lang.core.psi.MvNameIdentifierOwner"
        "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.sui.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvConstMixin"
    stubClass = "org.sui.lang.core.stubs.MvConstStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
fake SpecFunction ::= Attr* spec native? fun IDENTIFIER? TypeParameterList?
                        FunctionParameterList? ReturnType?
                        (';' | SpecCodeBlock)?
{
    implements = [
        "org.sui.lang.core.psi.MvQualNamedElement"
        "org.sui.lang.core.psi.MvFunctionLike"
        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
        "org.sui.lang.core.psi.MslScopeElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvSpecFunctionMixin"
    stubClass = "org.sui.lang.core.stubs.MvSpecFunctionStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private SpecFunctionItem ::= SpecFunctionInner
                            | NativeSpecFunctionInner

SpecFunctionInner ::= Attr* spec fun IDENTIFIER TypeParameterList?
                       FunctionParameterList ReturnType? (<<msl SpecCodeBlock>> | ';')
{
    pin = 3
    elementType = SpecFunction
}
NativeSpecFunctionInner ::= Attr* spec (native fun) IDENTIFIER TypeParameterList?
                             FunctionParameterList ReturnType? ';'
{
    pin = 3
    elementType = SpecFunction
}

fake SpecInlineFunction ::= Attr* native? fun IDENTIFIER? TypeParameterList?
                                FunctionParameterList? ReturnType?
                                (SpecCodeBlock | ';')?
{
    implements = [
        "org.sui.lang.core.psi.MvFunctionLike"
        "org.sui.lang.core.psi.MslScopeElement"
        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvSpecInlineFunctionMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private SpecInlineFunctionImpl ::= SpecInlineFunctionInner
                                    | NativeSpecInlineFunctionInner
//                                    | UninterpretedSpecInlineFunctionInner

SpecInlineFunctionInner ::= fun IDENTIFIER TypeParameterList?
                             FunctionParameterList ReturnType? (<<msl SpecCodeBlock>> | ';')
{
    pin = 1
    elementType = SpecInlineFunction
}
NativeSpecInlineFunctionInner ::= (native fun) IDENTIFIER TypeParameterList?
                                  FunctionParameterList ReturnType? ';'
{
    elementType = SpecInlineFunction
    pin = 1
}

SpecInlineFunctionStmt ::= SpecInlineFunctionImpl

fake Struct ::= Attr* native? STRUCT_KW IDENTIFIER? TypeParameterList? AbilitiesList?
                        (';' | StructBlock)?
{
    implements = [
        "org.sui.lang.core.psi.MvQualNamedElement"
        "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.sui.lang.core.psi.MvTypeParametersOwner"
        "org.sui.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvStructMixin"
    stubClass = "org.sui.lang.core.stubs.MvStructStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
}

private StructInnerFirst ::= STRUCT_KW
StructInner ::= Attr* StructInnerFirst IDENTIFIER TypeParameterList? AbilitiesList?
                            StructBlock
{
    pin = StructInnerFirst
    elementType = Struct
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private NativeStructInnerFirst ::= native STRUCT_KW
NativeStructInner ::= Attr* NativeStructInnerFirst IDENTIFIER TypeParameterList? AbilitiesList? ';'
{
    pin = NativeStructInnerFirst
    elementType = Struct
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private StructItem ::= StructInner | NativeStructInner

fake Function ::= Attr* native? FunctionVisibilityModifier? entry? inline?
                    fun? IDENTIFIER? TypeParameterList? FunctionParameterList?
                        ReturnType? AcquiresType?
                        (';' | CodeBlock)?
{
    implements = [
        "org.sui.lang.core.psi.MvQualNamedElement"
        "org.sui.lang.core.psi.MvFunctionLike"
        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
        "org.sui.lang.core.psi.MvModificationTrackerOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvFunctionMixin"
    stubClass = "org.sui.lang.core.stubs.MvFunctionStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionInnerNoVisFirst ::= fun
private FunctionInnerVisFirst ::= FunctionModifierSetInner fun { pin = 1 }
private FunctionInnerFirst ::= FunctionInnerVisFirst | FunctionInnerNoVisFirst

FunctionInner ::= Attr* FunctionInnerFirst FunctionSignatureInner CodeBlock
{
    pin = FunctionInnerFirst
    elementType = Function
//    recoverWhile = "FunctionSignature__recover"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
//
//private NativeFunctionInnerNoVisFirst ::= native fun
//private NativeFunctionInnerVisFirst ::= ((native FunctionVisibilityModifier)
//                                        | (FunctionVisibilityModifier native)) fun { pin = 1 }
//private NativeFunctionInnerFirst ::= NativeFunctionInnerNoVisFirst | NativeFunctionInnerVisFirst

NativeFunctionInner ::= Attr* NativeFunctionModifierSetInner fun FunctionSignatureInner ';'
{
    pin = NativeFunctionModifierSetInner
    elementType = Function
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionItem ::= NativeFunctionInner | FunctionInner

private FunctionSignatureInner ::= IDENTIFIER TypeParameterList?
                                    FunctionParameterList ReturnType? AcquiresType?
{
    recoverWhile = "FunctionSignatureInner_recover"
}
private FunctionSignatureInner_recover ::= !('{' | '}' | ';' | <<eof>> | Item_first)

private friend ::= <<friendKeyword>>

//fake FunctionModifierSet ::= native? FunctionVisibilityModifier? entry?

private FunctionModifierSetInner ::= <<functionModifierSet FunctionVisibilityModifier>>
//{
//    name = "modifier"
//}
private NativeFunctionModifierSetInner ::= <<nativeFunctionModifierSet FunctionVisibilityModifier>>
//{
//    elementType = FunctionModifierSet
//}
//NativeFunctionModifierSet ::= <<nativeFunctionModifierSet FunctionVisibilityModifier entry>>

//NativeFunctionModifierSet ::= <<functionModifierSet FunctionVisibilityModifier entry true>>

FunctionVisibilityModifier ::= public ('(' (SCRIPT_KW | friend) ')')?

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')' { pin = 1 }
private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= BindingPat TypeAnnotation {
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvFunctionParameterMixin"
}

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' ReturnTypeItem_with_recover { pin = 1 }
private ReturnTypeItem_with_recover ::= Type
{
    pin = 1
    recoverWhile = ReturnTypeItem_recover
}
private ReturnTypeItem_recover ::= !( '{' | ';' | acquires )

// acquires T, Record
AcquiresType ::= acquires AcquiresType_items { pin = 1 }
private AcquiresType_items ::= <<non_empty_comma_sep_items PathType>>
{
    recoverWhile = AcquiresType_items_recover
}
private AcquiresType_items_recover ::= !(';' | '{')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Structs
///////////////////////////////////////////////////////////////////////////////////////////////////
//StructSignature ::= STRUCT_KW IDENTIFIER TypeParameterList? AbilitiesList?
//{
//    pin = "struct"
//    implements = [
//        "org.sui.lang.core.psi.MvTypeParametersOwner"
//        "org.sui.lang.core.psi.MvNameIdentifierOwner"
//    ]
//    mixin = "org.sui.lang.core.psi.ext.MvStructMixin"
//}

//StructDef ::= Attr* StructSignature StructFieldsDefBlock
//{
//    pin = 2
//    implements = [ "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner" ]
//    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
//}

AbilitiesList ::= has <<non_empty_comma_sep_items Ability>> { pin = 1 }
Ability ::= copy | IDENTIFIER
{
    name = "ability"
}

StructBlock ::= '{' StructField_with_recover* '}' { pin = 1 }
private StructField_with_recover ::= !'}' StructField (',' | &'}')
{
    pin = 1
    recoverWhile = StructField_recover
}
private StructField_recover ::= !('}' | IDENTIFIER)

StructField ::= Attr* IDENTIFIER TypeAnnotation &(',' | '}')
{
    pin = 2
    implements = [
        "org.sui.lang.core.psi.MvMandatoryNameIdentifierOwner"
        "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.sui.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvStructFieldMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////////////////////////
// 'use 0x0::Transaction as MyTransaction;'

FriendDecl ::= Attr* friend FQModuleRef ';'
{
    pin = "friend"
    implements = [ "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner" ]
}

UseStmt ::= Attr* use (ItemUseSpeck | ModuleUseSpeck) ';' {
    pin = "use"
    implements = [ "org.sui.lang.core.psi.ext.MvDocAndAttributeOwner" ]
}
ModuleUseSpeck ::= (AddressRef !'::') | FQModuleRef UseAlias?
{
    name = "qual path to module"
    implements = [
        "org.sui.lang.core.psi.MvNamedElement"
        "org.sui.lang.core.psi.MvUseSpeck"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvModuleUseSpeckMixin"
}
ItemUseSpeck ::= FQModuleRef '::' (UseItem | UseItemGroup)
{
    pin = 2
    name = "qual path to imported item"
    implements = [
        "org.sui.lang.core.psi.MvUseSpeck"
    ]
}

UseItemGroup ::= '{' <<non_empty_comma_sep_items MultiItemUse_member_with_recovery>>? '}'
{
    pin = 1
}
private MultiItemUse_member_with_recovery ::= !('}' | ';' | <<eof>>) UseItem
{
    pin = 1
}

UseItem ::= IDENTIFIER UseAlias?
{
    pin = 1
    name = "item name"
    implements = [
        "org.sui.lang.core.psi.MvNamedElement"
        "org.sui.lang.core.resolve.ref.MvMandatoryReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvUseItemMixin"
}
UseAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.sui.lang.core.psi.MvNameIdentifierOwner" ]
    mixin = "org.sui.lang.core.psi.ext.MvUseAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation ::= ':' Type {
    pin = 1
    name = "type annotation"
}

Type ::= RefType | PathType | TupleType | LambdaType | UnitType | ParensType
ParensType ::= '(' (Type !',') ')' { pin = 2 }

UnitType ::= '(' ')'
RefType ::= RefTypeStart Type
{
    pin = 1
}
RefTypeStart ::= '&' mut?

PathType ::= Path
{
    name = "type"
}

TupleType ::= '(' Type ',' (Type ','?)* ')' { pin = 3 }
//TupleType ::= ('(' !')') TupleTypeItem_with_recover+ ')' { pin = 1 }
//private TupleTypeItem_with_recover ::= !')' Type (',' | &')')
//{
//    pin = 1
//    recoverWhile = TupleTypeItem_recover
//}
//private TupleTypeItem_recover ::= !(')' | '{' | IDENTIFIER)

LambdaType ::= '|' <<non_empty_comma_sep_items LambdaTypeParam>>? '|' Type? { pin = 1 }
LambdaTypeParam ::= Type

TypeParameterList ::= '<' TypeParameter_with_recover* '>'
{
    pin = 1
    name = "type parameters"
}
private TypeParameter_with_recover ::= !'>' TypeParameterImpl (',' | &'>')
{
    pin = 1
    recoverWhile = TypeParameter_recover
}
private TypeParameter_recover ::= !('>' | '(' | '{' | phantom | IDENTIFIER)

fake TypeParameter ::= phantom? IDENTIFIER? TypeParamBound? {
    pin = 2
    implements = [
        "org.sui.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvTypeParameterMixin"
}

private TypeParameterImpl ::= PlainTypeParameter | PhantomTypeParameter
PlainTypeParameter ::= IDENTIFIER TypeParamBound? { pin = 1 elementType = TypeParameter }
PhantomTypeParameter ::= phantom IDENTIFIER TypeParamBound? { pin = 1 elementType = TypeParameter }

TypeParamBound ::= ':' TypeParamBound_items
{
    pin = 1
}
private TypeParamBound_items ::= Ability ( '+' Ability )*
{
    recoverWhile = TypeParamBound_items_recover
}
private TypeParamBound_items_recover ::= !('>' | ',')

TypeArgumentList ::= '<' <<non_empty_comma_sep_items (TypeArgument &(','|'>'))>>? '>' {
    name = "type arguments"
}
TypeArgument ::= Type

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= TuplePat
        | StructPat
        | WildPat
        | BindingPat

WildPat ::= '_'
//DerefPat ::= '*' Pat
//BorrowPat ::= '&' Pat
//DotPat ::= IDENTIFIER '.' IDENTIFIER { pin = 2 }

BindingPat ::= IDENTIFIER {
    implements = [
        "org.sui.lang.core.psi.MvMandatoryNameIdentifierOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvBindingPatMixin"
}

TuplePat ::= '(' <<non_empty_comma_sep_items Pat>>? ')'

StructPat ::= Path StructPatFieldsBlock
StructPatFieldsBlock ::= '{' StructPatField_with_recover* '}' { pin = 1 }

private StructPatField_with_recover ::= !'}' StructPatField (',' | &'}')
{
    pin = 1
    recoverWhile = StructPatField_recover

}
private StructPatField_recover ::= !('}' | IDENTIFIER)

StructPatField ::= (BindingPat !':') | (IDENTIFIER StructPatFieldBinding)
{
    implements = [
        "org.sui.lang.core.resolve.ref.MvStructPatFieldReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvStructPatFieldMixin"
}
StructPatFieldBinding ::= ':' Pat

///////////////////////////////////////////////////////////////////////////////////////////////////
// Stmts
///////////////////////////////////////////////////////////////////////////////////////////////////
Stmt ::= LetMoveStmt | ExprStmt

SpecExprStmt ::= (SpecExpr_item !'}') ';' { pin = 1 }
private SpecExpr ::= SpecExprStmt_items | Expr
private SpecExpr_item ::= SpecExprStmt_items | ExprStmt_expr
{
    recoverWhile = SpecExprStmt_recover
}
private SpecExprStmt_recover ::= !(';' | '}' | SpecExpr_first | Expr_first)
private SpecExprStmt_first ::= let | if | while
                                    | include | apply | pragma | emits | assume | assert | ensures
                                    | axiom | modifies | aborts_if | aborts_with | requires | invariant

private SpecExprStmt_items ::= AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr | AbortsWithSpecExpr
                | RequiresSpecExpr | DecreasesSpecExpr
                | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr | AxiomSpecExpr
                | EmitsSpecExpr
//{
//    recoverWhile = ExprStmt_recover
//}

private post ::= <<postKeyword>>
fake LetStmt ::= let post? Pat? TypeAnnotation? Initializer? ';'?
{
    implements = ["org.sui.lang.core.psi.MvTypeAnnotationOwner"]
}

LetMoveStmt ::= let Pat TypeAnnotation? Initializer? ';'
{
    pin = 1
    elementType = LetStmt
}
LetMslStmt ::= (let post?) Pat TypeAnnotation? Initializer? ';'
{
    pin = 1
    elementType = LetStmt
}

ExprStmt ::= (ExprStmt_expr !('}')) ';' { pin = 1 }
private ExprStmt_expr ::= ItemSpecBlockExpr
                            | Expr
//IfExpr
//                            | LoopExpr
//                            | WhileExpr
{
    recoverWhile = "ExprStmt_recover"
}
private ExprStmt_recover ::= !(';' | '}' | <<mslOnly SpecExpr_first>> | Expr_first)
private Expr_first ::= let | if | while | loop | continue | break | return | spec
                        | copy | move | abort
//                        | (<<VECTOR_IDENTIFIER>> ('<' | '['))
                        | IDENTIFIER
                        | '*' | '&' | '!' | '|' | '{' | '('
                        | AnyLitToken_first
                        | (AddressRef '::')
private SpecExpr_first ::= include | apply | pragma | emits | assume | assert | ensures
                            | axiom | modifies | aborts_if | aborts_with | requires
                            | invariant | choose | decreases | update

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= CodeBlock
CodeBlock ::= '{' CodeBlock_items '}'
{
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvImportsOwner"
        "org.sui.lang.core.psi.AnyBlock"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvCodeBlockMixin"
}

private CodeBlock_items ::= UseStmt*
                            Stmt*
                            ExprStmt_expr?
{
    recoverWhile = "CodeBlock_items_recover"
}
private CodeBlock_items_recover ::= !('}' | <<eof>>)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExpr
//        | SpecVisRestrictedExpr
        | RangeExpr
        | (ForallQuantExpr | ExistsQuantExpr | ChooseQuantExpr)
        | CastExpr
        | ImplyBinExpr_items
        | OrBinExpr
        | AndBinExpr
        | LogicalEqExpr_items
        | BitOrBinExpr
        | BitXorBinExpr
        | BitAndBinExpr
        | (LeftShiftBinExpr | RightShiftBinExpr)
        | AddExpr_items
        | MulExpr_items
        | ControlFlowExpr_items
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

fake BinaryExpr ::= Expr BinaryOp Expr {
    methods = [
        left="/Expr[0]"
        right="/Expr[1]"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvBinaryExprMixin"
}

//noinspection BnfUnusedRule
fake BinaryOp ::= '<==>' | '==>' | '='
                    | '==' | '!='
                    | '<' | '>' | '<=' | '>='
                    | '<<' | '>>'
                    | '+' | '-' | '*' | '/' | '%'
                    | '||' | '&&' | '|' | '&' | '^'


private MulExpr_items ::= DivBinExpr | MulBinExpr | ModBinExpr
private AddExpr_items ::= PlusBinExpr | MinusBinExpr
private LogicalEqExpr_items ::= EqualsBinExpr | NotEqualsBinExpr | LessEqualsBinExpr | LessBinExpr | GreaterEqualsBinExpr | GreaterBinExpr

private ControlFlowExpr_items ::= IfExpr | LoopExpr | WhileExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
                    AnnotatedExpr
                    | TupleLitOrParenExpr
                    | StructLitExpr
                    | VectorLitExpr
                    | DotExpr
                    | IndexExpr
                    | (CallExpr | MacroCallExpr)
                    | RefExpr
                    | LambdaExpr
                    | LitExpr
                    | CodeBlockExpr


CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

EqualsBinExpr ::= Expr (!eqeq_gt EqualsBinOp) Expr
NotEqualsBinExpr ::= Expr NotEqualsBinOp Expr

EqualsBinOp ::= '=='
NotEqualsBinOp ::= '!='

// booleans
OrBinExpr ::= Expr OrBinOp Expr
AndBinExpr ::= Expr AndBinOp Expr

OrBinOp ::= oror
AndBinOp ::= andand

LessBinExpr ::= Expr (!(ltlt | lt_eqeq_gt) LessBinOp) Expr
GreaterBinExpr ::= Expr (!gtgt GreaterBinOp) Expr
LessEqualsBinExpr ::= Expr LessEqualsBinOp Expr
GreaterEqualsBinExpr ::= Expr GreaterEqualsBinOp Expr

LessBinOp ::= '<'
GreaterBinOp ::= '>'
LessEqualsBinOp ::= lteq
GreaterEqualsBinOp ::= gteq

// bitwise ops
BitOrBinExpr ::= Expr (!oror BitOrBinOp) Expr
BitAndBinExpr ::= Expr (!andand BitAndBinOp) Expr
BitXorBinExpr ::= Expr BitXorBinOp Expr

BitOrBinOp ::= '|'
BitAndBinOp ::= '&'
BitXorBinOp ::= '^'

// arithmetic
MulBinExpr ::= Expr MulBinOp Expr
DivBinExpr ::= Expr DivBinOp Expr
PlusBinExpr ::= Expr PlusBinOp Expr
MinusBinExpr ::= Expr MinusBinOp Expr
ModBinExpr ::= Expr ModBinOp Expr

MulBinOp ::= '*'
DivBinOp ::= '/'
PlusBinOp ::= '+'
MinusBinOp ::= '-'
ModBinOp ::= '%'

// bit shifts
LeftShiftBinExpr ::= Expr LeftShiftBinOp Expr
RightShiftBinExpr ::= Expr RightShiftBinOp Expr

LeftShiftBinOp ::= ltlt
RightShiftBinOp ::= gtgt

// imply
private ImplyBinExpr_items ::= ImplyBinExpr | PartialImplyBinExpr
ImplyBinExpr ::= Expr ImplyBinOp Expr
PartialImplyBinExpr ::= Expr PartialImplyBinOp Expr

ImplyBinOp ::= <<includeStmtModeFalse>> <<mslOnly eqeq_gt>>
PartialImplyBinOp ::= <<mslOnly lt_eqeq_gt>>

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr

CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?
//private ReturnExpr ::= EmptyReturnExpr | ValueReturnExpr
//EmptyReturnExpr ::= return { elementType = ReturnExpr }
//ValueReturnExpr ::= return Expr { elementType = ReturnExpr }

AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

VectorLitExpr ::= <<VECTOR_IDENTIFIER>> ('<' TypeArgument '>')? VectorLitItems
VectorLitItems ::= '[' <<non_empty_comma_sep_items Expr>>? ']'
{
    pin = 1
}

StructLitExpr ::= <<includeStmtModeFalse>> Path StructLitFieldsBlock
{
    implements = ["org.sui.lang.core.psi.PathExpr"]
}
StructLitFieldsBlock ::= '{' StructLitField_with_recover* '}' { pin = 1 }

private StructLitField_with_recover ::= !'}' StructLitField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLitField_recover
}
private StructLitField_recover ::= !('}' | IDENTIFIER)

StructLitField ::= IDENTIFIER StructLitFieldInit?
{
    implements = [
        "org.sui.lang.core.resolve.ref.MvStructFieldLitReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvStructLitFieldMixin"
}

private StructLitFieldInit ::= ':' Expr { pin = 1 }

fake TupleLitExpr ::= '(' Expr+ ')' {
    pin = 2
}
fake ParensExpr ::= '(' Expr ')' {
    pin = 1
}

TupleLitOrParenExpr ::= '(' Expr (TupleLitExprUpper | ')') {
    pin = 1
    elementType = ParensExpr
}
upper TupleLitExprUpper ::= ',' [ Expr (',' Expr)* ','? ] ')' {
    pin = 1
    elementType = TupleLitExpr
}

//ParensExpr ::= '(' Expr !':' ')'
//TupleLitExpr ::= '(' Expr ',' <<comma_sep_items Expr>>? ')' { pin = 3 }

//TupleOrParenExpr ::= OuterAttr* '(' AnyExpr (TupleExprUpper | ')') {
//  pin = 2
//  elementType = ParenExpr
//}
//upper TupleExprUpper ::= ',' [ AnyExpr (',' AnyExpr)* ','? ] ')' { pin = 1 elementType = TupleExpr }

LambdaExpr ::= '|' <<non_empty_comma_sep_items BindingPat>> '|' Expr { pin = 1 }

RangeExpr ::= Expr dotdot Expr { pin = 2 }


private HEX_INTEGER_LITERAL ::= <<hexIntegerLiteral>>
LitExpr ::= HEX_INTEGER_LITERAL
                | BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | AddressLit

private AnyLitToken_first ::= HEX_INTEGER_LITERAL
                                  | BOOL_LITERAL
                                  | INTEGER_LITERAL
                                  | HEX_STRING_LITERAL
                                  | BYTE_STRING_LITERAL
                                  | '@'

AddressLit ::= '@' AddressRef { pin = 1 }

CallExpr ::= (Path &'(') ValueArgumentList {
    pin = 1
    implements = ["org.sui.lang.core.psi.PathExpr"]
}
ValueArgumentList ::= '(' ValueArgumentList_items? ')' {
    pin = 1
}
private ValueArgumentList_items ::= ValueArgument (',' ValueArgument)* ','?

ValueArgument ::= !')' Expr &(',' | ')') {
    pin = 1
    recoverWhile = ValueArgument_recover
}
private ValueArgument_recover ::= !(<<mslOnly SpecExpr_first>> | Expr_first | ')' | '}' | ';' | ',')

//ValueArgument ::= Expr

//private ValueArgumentList_items ::= <<comma_sep_items ValueArgument>>
//{
//    recoverWhile = ValueArgumentList_items_recovery
//}
//private ValueArgumentList_items_recovery ::= !(';' | ')')


IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock { pin = 1 }
WhileExpr ::= while Condition AnyBlock { pin = 1 }

AssignmentExpr ::= Expr Initializer { rightAssociative = true }
Initializer ::= '=' Expr { pin = 1 }

BorrowExpr ::= '&' mut? Expr

DotExpr ::= Expr DotExpr_field
// Do not inline this rule, it breaks expression parsing
private DotExpr_field ::= '.' (!'.') StructDotField {
    pin = 2
    consumeTokenMethod = "consumeTokenFast"
}
StructDotField ::= !(<<VECTOR_IDENTIFIER>> ('[' | '<')) IDENTIFIER !('(' | '::' | '!' | '{')
{
    implements = ["org.sui.lang.core.resolve.ref.MvStructDotFieldReferenceElement"]
    mixin = "org.sui.lang.core.psi.ext.MvStructDotFieldMixin"
}

IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

RefExpr ::= Path !'{' {
    implements = ["org.sui.lang.core.psi.PathExpr"]
}

//private Path ::= QualPath | LocalPath
//fake Path ::= (ModuleRef '::')? IDENTIFIER? TypeArgumentList?
//{
//    implements = ["org.sui.lang.core.resolve.ref.MvReferenceElement"]
//    mixin = "org.sui.lang.core.psi.ext.MvPathMixin"
//}

//LocalPath ::= IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }
//QualPath ::= ModuleRef '::' IDENTIFIER TypeArgumentList? { pin = 1 elementType = Path }

Path ::= (ModulePathIdent | FQModulePathIdent | LocalPathIdent) TypeArgumentList?
{
    implements = ["org.sui.lang.core.resolve.ref.MvPathReferenceElement"]
    mixin = "org.sui.lang.core.psi.ext.MvPathMixin"
}

//fake PathIdent ::= ((FQModuleRef | ModuleRef) '::')? IDENTIFIER?

private LocalPathIdent ::= IDENTIFIER
private ModulePathIdent ::= ModuleRef ('::' !(IDENTIFIER '::')) IDENTIFIER
{
    pin = 2
//    elementType = PathIdent
}
private FQModulePathIdent ::= FQModuleRef '::' IDENTIFIER
{
    pin = 1
//    elementType = PathIdent
}

ModuleRef ::= IDENTIFIER | FQModuleRef
{
    implements = ["org.sui.lang.core.resolve.ref.MvReferenceElement"]
    mixin = "org.sui.lang.core.psi.ext.MvModuleRefMixin"
}

FQModuleRef ::= AddressRef '::' IDENTIFIER
{
    pin = 2
    extends = ModuleRef
    implements = [
        "org.sui.lang.core.resolve.ref.MvFQModuleReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvFQModuleRefMixin"
}

AddressRef ::= NamedAddress
                | DIEM_ADDRESS
                | INTEGER_LITERAL
                | PLACEHOLDER_ADDRESS
                | BECH32_ADDRESS
                | POLKADOT_ADDRESS
NamedAddress ::= IDENTIFIER
{
    implements = ["org.sui.lang.core.resolve.ref.NamedAddressReferenceElement"]
    mixin = "org.sui.lang.core.psi.ext.MvNamedAddressMixin"
}

/// Macros
MacroCallExpr ::= MacroIdent ValueArgumentList { pin = 1 }
MacroIdent ::= IDENTIFIER '!'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Specs
///////////////////////////////////////////////////////////////////////////////////////////////////
private assert ::= <<assertKeyword>>
private assume ::= <<assumeKeyword>>
private modifies ::= <<modifiesKeyword>>
private requires ::= <<requiresKeyword>>
private decreases ::= <<decreasesKeyword>>
private ensures ::= <<ensuresKeyword>>
private aborts_if ::= <<abortsIfKeyword>>
private aborts_with ::= <<abortsWithKeyword>>
private include ::= <<includeKeyword>>
private choose ::= <<chooseKeyword>>
private min ::= <<minKeyword>>

private invariant ::= <<invariantKeyword>>
private axiom ::= <<axiomKeyword>>
private forall ::= <<forallKeyword>>
private exists ::= <<existsKeyword>>
private with ::= <<withKeyword>>
private where ::= <<whereKeyword>>
private in ::= <<inKeyword>>
private update ::= <<updateKeyword>>

private pragma ::= <<pragmaKeyword>>
private local ::= <<localKeyword>>
private global ::= <<globalKeyword>>
private emits ::= <<emitsKeyword>>
private to ::= <<toKeyword>>
private apply ::= <<applyKeyword>>
private except ::= <<exceptKeyword>>

//private SpecItem_first ::= assert | assume | modifies | requires | ensures | aborts_if | include | choose | axiom
//                         | invariant | pragma | local | global | emits
//private SpecItem_recover ::= !('}' | <<eof>> | SpecItem_first)

ModuleSpec ::= Attr* spec FQModuleRef ModuleSpecBlock
{
    pin = "spec"
    name = "module spec declaration"
    mixin = "org.sui.lang.core.psi.ext.MvModuleSpecMixin"
    stubClass = "org.sui.lang.core.stubs.MvModuleSpecStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
ModuleSpecBlock ::= '{' ModuleSpecBlock_item_with_recover* '}'
{
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvImportsOwner"
        "org.sui.lang.core.psi.MslScopeElement"
        "org.sui.lang.core.psi.AnyBlock"
    ]
}

private ModuleSpecBlock_item_with_recover ::= !('}' | <<eof>>) ModuleSpecBlock_item
{
    pin = 1
    recoverWhile = ModuleSpecBlock_item_recover
}
private ModuleSpecBlock_item ::= UseStmt | SpecFunctionItem | Schema | ModuleItemSpec | ItemSpec
private ModuleSpecBlock_item_recover ::= !('}' | <<eof>> | spec | use)
// top-level recovery
//private Item_first ::= use | public | native | fun | CONST_KW | STRUCT_KW | spec | friend | Attr | entry
//private Item_recover ::= !('}' | <<eof>> | Item_first)

//AnySpec ::= ItemSpec | ModuleKeywordSpec

ModuleItemSpec ::= spec MODULE_KW <<msl SpecCodeBlock>>
{
    pin = 2
    implements = [
        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
        "org.sui.lang.core.psi.MslScopeElement"
    ]
}
ItemSpec ::= (spec !MODULE_KW) ItemSpecRef ItemSpecSignature? <<msl SpecCodeBlock>>
{
    pin = 1
    implements = [
        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
        "org.sui.lang.core.psi.MslScopeElement"
        "org.sui.lang.core.psi.MvModificationTrackerOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvItemSpecMixin"
}
ItemSpecSignature ::= ItemSpecTypeParameterList? ItemSpecFunctionParameterList ReturnType?
{
    pin = ItemSpecFunctionParameterList
    name = "function signature"
}

ItemSpecTypeParameterList ::= '<' ItemSpecTypeParameter_with_recover* '>'
{
    pin = 1
}
private ItemSpecTypeParameter_with_recover ::= !'>' ItemSpecTypeParameter (',' | &'>')
{
    pin = 1
    recoverWhile = ItemSpecTypeParameter_recover
}
private ItemSpecTypeParameter_recover ::= !('>' | '(' | '{' | phantom | IDENTIFIER)

ItemSpecTypeParameter ::= IDENTIFIER TypeParamBound? {
    pin = 1
    implements = [
        "org.sui.lang.core.resolve.ref.MvItemSpecParameterReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvItemSpecTypeParameterMixin"
}

ItemSpecFunctionParameterList ::= '(' ItemSpecFunctionParameter_with_recover* ')' { pin = 1 }
private ItemSpecFunctionParameter_with_recover ::= !(')' | '{' | ';') ItemSpecFunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = ItemSpecFunctionParameter_recover
}
private ItemSpecFunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

ItemSpecFunctionParameter ::= IDENTIFIER TypeAnnotation {
    pin = 1
    implements = [
        "org.sui.lang.core.resolve.ref.MvItemSpecParameterReferenceElement"
        "org.sui.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvItemSpecFunctionParameterMixin"
}

ItemSpecRef ::= IDENTIFIER
{
    implements = ["org.sui.lang.core.resolve.ref.MvReferenceElement"]
    mixin = "org.sui.lang.core.psi.ext.MvItemSpecRefMixin"
}

//ItemSpec ::= (spec IDENTIFIER) <<msl ItemSpecBlock>>
//{
//    pin = 1
////    extends = AnySpec
//    implements = ["org.sui.lang.core.resolve.ref.MvMandatoryReferenceElement"]
//    mixin = "org.sui.lang.core.psi.ext.MvItemSpecMixin"
//}
//ModuleKeywordSpec ::= (spec MODULE_KW) <<msl ItemSpecBlock>> {
//    pin = 1
////    extends = AnySpec
//}

Schema ::= (spec schema) IDENTIFIER TypeParameterList? <<msl SpecCodeBlock>> {
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvTypeParametersOwner"
        "org.sui.lang.core.psi.MvQualNamedElement"
        "org.sui.lang.core.psi.MvNameIdentifierOwner"
        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
        "org.sui.lang.core.psi.MslScopeElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvSchemaMixin"
    stubClass = "org.sui.lang.core.stubs.MvSchemaStub"
    elementTypeFactory = "org.sui.lang.core.stubs.StubsKt.factory"
}

ItemSpecBlockExpr ::= spec <<msl SpecCodeBlock>> {
    implements = [
        "org.sui.lang.core.psi.MslScopeElement"
    ]
}

SpecCodeBlock ::= '{' ItemSpecBlock_items '}'
{
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvImportsOwner"
        "org.sui.lang.core.psi.AnyBlock"
//        "org.sui.lang.core.types.infer.MvInferenceContextOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvSpecCodeBlockMixin"
}
private ItemSpecBlock_items ::= (SpecStmt | ExprStmt)* (SpecExprStmt_items | ExprStmt_expr)?
{
    recoverWhile = ItemSpecBlock_items_recover
}
private ItemSpecBlock_items_recover ::= !('}' | <<eof>>)

//private SpecExpr_item ::= SpecExprStmt_items | ExprStmt_items

//private SpecItem ::= !('}' | <<eof>>) SpecStmt
//{
//    pin = 1
//    recoverWhile = SpecItem_recover
//}

//private SpecItemExpr ::= SpecBlockFinishingExpr
//private SpecBlockStmt_with_recover ::= SpecStmt
//private SpecBlockFinishingExpr_with_recover ::= !('}' | <<eof>>) SpecBlockFinishingExpr

private SpecStmt ::= UseStmt
                       | SchemaFieldStmtImpl
                       | GlobalVariableStmt
                       | SpecInlineFunctionStmt
//                       | NativeFunctionDefSpecStmt
//                       | UninterpretedFunctionDefSpecStmt
                       | PragmaSpecStmt
//                               | AssumeSpecStmt
//                               | AssertSpecStmt
//                               | AbortsIfSpecStmt
//                               | RequiresSpecStmt
//                               | EnsuresSpecStmt
//                               | ModifiesSpecStmt
                               | IncludeStmt
                               | UpdateSpecStmt
//                               | IncludeStmts
//                               | InvariantSpecStmt
//                               | AxiomSpecStmt
                               | ApplySchemaStmt
//                               | EmitsSpecStmt
//                               | AggregatePredicateSpecStmt
//                               | SpecBlockSpecStmt
                               | LetMslStmt
//                               | ChooseSpecStmt
//                               | ExprSpecStmt
                               | SpecExprStmt
//{
//    recoverWhile = SpecStmt_recover
//}
//private SpecStmt_recover ::= !'}'

//ExprSpecStmt ::= ExprSpecStmt_item ';'
//private ExprSpecStmt_item ::= SpecExpr | AggregateExpr | Expr
//
//private SpecBlockFinishingExpr ::= SpecExpr | AggregateExpr | Expr

fake SchemaFieldStmt ::= local? BindingPat TypeAnnotation ';'
{
    implements = [
        "org.sui.lang.core.psi.MvTypeAnnotationOwner"
    ]
}

private SchemaFieldStmtImpl ::= SchemaFieldStmt_local | SchemaFieldStmt_simple

SchemaFieldStmt_simple ::= BindingPat TypeAnnotation ';' {
    pin = 2
    elementType = SchemaFieldStmt
}
SchemaFieldStmt_local ::= local BindingPat TypeAnnotation ';' {
    pin = 1
    elementType = SchemaFieldStmt
}

GlobalVariableStmt ::= global IDENTIFIER TypeParameterList? TypeAnnotation ('=' Expr)? ';'
{
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvNameIdentifierOwner"
        "org.sui.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvGlobalVariableMixin"
}

//private post ::= <<postKeyword>>
//LetSpecStmt ::= (let post?) Pat TypeAnnotation? Initializer? ';' { pin = 1 }
PragmaSpecStmt ::= pragma <<non_empty_comma_sep_items PragmaAttribute>> ';' { pin = 1 }
PragmaAttribute ::= IDENTIFIER ('=' Expr)?

AbortsIfSpecExpr ::= aborts_if SpecPropertyList? Expr AbortsIfWith? {
    pin = 1
    implements = [ "org.sui.lang.core.psi.MvBoolSpecExpr" ]
}
AbortsIfWith ::= with Expr { pin = 1 }

AbortsWithSpecExpr ::= aborts_with SpecPropertyList? <<non_empty_comma_sep_items Expr>> { pin = 1 }

AssertSpecExpr ::= assert SpecPropertyList? Expr {
    pin = 1
    implements = [ "org.sui.lang.core.psi.MvBoolSpecExpr" ]
}
AssumeSpecExpr ::= assume SpecPropertyList? Expr {
    pin = 1
    implements = [ "org.sui.lang.core.psi.MvBoolSpecExpr" ]
}
EnsuresSpecExpr ::= ensures SpecPropertyList? SpecExpr {
    pin = 1
    implements = [ "org.sui.lang.core.psi.MvBoolSpecExpr" ]
}
RequiresSpecExpr ::= requires SpecPropertyList? Expr {
    pin = 1
    implements = [ "org.sui.lang.core.psi.MvBoolSpecExpr" ]
}
DecreasesSpecExpr ::= decreases SpecPropertyList? Expr { pin = 1 }

ModifiesSpecExpr ::= modifies SpecPropertyList? Expr { pin = 1 }

IncludeStmt ::= include SpecPropertyList? IncludeItem ';' { pin = 1 }

UpdateSpecStmt ::= update UpdateExpr_items '=' Expr ';' {
    pin = 1
}
private UpdateExpr_items ::= UnaryExpr | BorrowExpr | AtomExpr

IncludeItem ::= SchemaIncludeItem | AndIncludeItem | IfElseIncludeItem | ImplyIncludeItem

SchemaIncludeItem ::= SchemaLit &(';' | '}' | SpecExprStmt_first)
{
    extends = IncludeItem
}
AndIncludeItem ::= SchemaLit AndBinOp SchemaLit
{
    extends = IncludeItem
}
ImplyIncludeItem ::= <<includeStmtMode Expr>> ImplyBinOp SchemaLit
{
    extends = IncludeItem
}
IfElseIncludeItem ::= if Condition SchemaLit else SchemaLit
{
    extends = IncludeItem
}

SchemaLit ::= Path SchemaFieldsBlock?

SchemaFieldsBlock ::= '{' SchemaField_with_recover* '}' { pin = 1 }
private SchemaField_with_recover ::= !'}' SchemaLitField (',' | &'}')
{
    pin = 1
    recoverWhile = SchemaField_recover
}
private SchemaField_recover ::= !('}' | IDENTIFIER)

SchemaLitField ::= IDENTIFIER SchemaLitFieldInit?
{
    implements = [
        "org.sui.lang.core.resolve.ref.MvSchemaRefFieldReferenceElement"
    ]
    mixin = "org.sui.lang.core.psi.ext.MvSchemaLitFieldMixin"
}
private SchemaLitFieldInit ::= ':' Expr { pin = 1 }

private PatternVis ::= <<patternVisibility>>
private PatternIdent ::= <<patternIdent>>

//fake FunctionPatternIdent ::= ('*' | IDENTIFIER)+
FunctionPattern ::= PatternVis? PatternIdent TypeParameterList? {
    pin = 2
//    implements = [ "org.sui.lang.core.psi.MvTypeParametersOwner" ]
}

InvariantSpecExpr ::= invariant TypeParameterList? update? SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvBoolSpecExpr"
//        "org.sui.lang.core.psi.MvTypeParametersOwner"
    ]
}

AxiomSpecExpr ::= axiom TypeParameterList? SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.sui.lang.core.psi.MvBoolSpecExpr"
        "org.sui.lang.core.psi.MvTypeParametersOwner"
    ]
}

SpecPropertyList ::= '[' SpecPropertyList_items? ']'
private SpecPropertyList_items ::= SpecProperty (',' SpecProperty)* ','?

SpecProperty ::= !']' IDENTIFIER ('=' LitExpr)? &(',' | ']') {
    pin = 1
//    recoverWhile = SpecProperty_recover
}
//private SpecProperty_recover ::= !(<<mslOnly SpecExpr_first>> | Expr_first | ']' | '}' | ';' | ',')

EmitsSpecExpr ::= emits SpecPropertyList? Expr to Expr EmitsCondition? { pin = 1 }
EmitsCondition ::= if Expr { pin = 1 }

ApplySchemaStmt ::= apply SchemaRef ApplyTo ApplyExcept? ';' { pin = 1 }
ApplyTo ::= to <<non_empty_comma_sep_items FunctionPattern>> { pin = 1 }
ApplyExcept ::= except <<non_empty_comma_sep_items FunctionPattern>> { pin = 1 }

SchemaRef ::= Path ('{' <<non_empty_comma_sep_items ApplySchemaNameAttribute>> '}')?
//{
//    implements = [
//        "org.sui.lang.core.psi.MvQualSchemaReferenceElement"
//    ]
//    mixin = "org.sui.lang.core.psi.ext.MvApplySchemaNameMixin"
//}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr

//SpecVisRestrictedExpr ::= SpecVisibility Expr

//AggregatePredicateSpecStmt ::= AggregateExpr ';'
//AggregateExpr ::= QuantExpr_items (':' Expr)?
//{
//    rightAssociative = true
//}

QuantWhere ::= where Expr
{
    pin = 1
}

ForallQuantExpr ::= <<mslOnly forall>> QuantBindings QuantWhere? ':' Expr
{
    pin = 1
    rightAssociative = true
    implements = [ "org.sui.lang.core.psi.ext.MvQuantExpr" ]
}
ExistsQuantExpr ::= <<mslOnly exists>> QuantBindings QuantWhere? ':' Expr
{
    pin = 1
    rightAssociative = true
    implements = [ "org.sui.lang.core.psi.ext.MvQuantExpr" ]
}
QuantBindings ::= <<non_empty_comma_sep_items QuantBinding>>

// TODO: should be single QuantBinding, multiple are not allowed
ChooseQuantExpr ::= choose min? QuantBindings QuantWhere?
{
    pin = 1
    implements = [ "org.sui.lang.core.psi.ext.MvQuantBindingsOwner" ]
}
QuantBinding ::= RangeQuantBinding | TypeQuantBinding

RangeQuantBinding ::= BindingPat in Expr {
    pin = 2
    extends = QuantBinding
}
TypeQuantBinding ::= BindingPat ':' Type {
    pin = 2
    extends = QuantBinding
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private dotdot ::= <<dotdotImpl>>

private meta non_empty_comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
